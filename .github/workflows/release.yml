name: Release

permissions:
  contents: write
  pull-requests: write
  id-token: write
  attestations: write

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'build.rs'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: Build and Test
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Cache cargo index
      uses: actions/cache@v4
      with:
        path: ~/.cargo/git
        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Cache cargo build
      uses: actions/cache@v4
      with:
        path: target
        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Build
      run: cargo build --verbose
    
    - name: Run tests
      run: cargo test --verbose
  
  create-release:
    name: Create Release
    needs: build
    runs-on: windows-latest
    environment: release
    permissions:
      contents: write
      id-token: write
      attestations: write
    
    outputs:
      BINARY_PATH: ${{ steps.build_info.outputs.BINARY_PATH }}
      SBOM_PATH: ${{ steps.sbom_info.outputs.SBOM_PATH }}
      VERSION: ${{ steps.version.outputs.VERSION }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Get version from Cargo.toml
      id: version
      shell: pwsh
      run: |
        $content = Get-Content Cargo.toml -Raw
        $content -match 'version = "([^"]+)"' | Out-Null
        $version = $matches[1]
        Write-Output "VERSION=$version" >> $env:GITHUB_OUTPUT
        Write-Output "Version: $version"
    
    - name: Get last release version
      id: last_version
      shell: pwsh
      run: |
        try {
          $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/latest" `
            -Headers @{ Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}" } `
            -ErrorAction Stop
          $lastTag = $response.tag_name -replace '^v', ''
          Write-Output "LAST_VERSION=$lastTag" >> $env:GITHUB_OUTPUT
          Write-Output "Last version: $lastTag"
        } catch {
          Write-Output "LAST_VERSION=0.0.0" >> $env:GITHUB_OUTPUT
          Write-Output "No previous releases found"
        }
    
    - name: Verify version was updated
      shell: pwsh
      run: |
        $currentVersion = "${{ steps.version.outputs.VERSION }}"
        $lastVersion = "${{ steps.last_version.outputs.LAST_VERSION }}"
        
        if ($currentVersion -eq $lastVersion) {
          Write-Error "Version in Cargo.toml ($currentVersion) has not been updated from the last release ($lastVersion). Please bump the version."
          exit 1
        }
        Write-Output "Version updated from $lastVersion to $currentVersion âœ“"
    
    - name: Check if tag already exists
      id: check_tag
      shell: pwsh
      run: |
        $tag = "v${{ steps.version.outputs.VERSION }}"
        $tagExists = @(git tag -l $tag).Count -gt 0
        if ($tagExists) {
          Write-Output "TAG_EXISTS=true" >> $env:GITHUB_OUTPUT
          Write-Output "Tag $tag already exists"
        } else {
          Write-Output "TAG_EXISTS=false" >> $env:GITHUB_OUTPUT
          Write-Output "Tag $tag does not exist, will create"
        }
    
    - name: Create git tag
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        git tag -a v${{ steps.version.outputs.VERSION }} -m "Release v${{ steps.version.outputs.VERSION }}"
        git push origin v${{ steps.version.outputs.VERSION }}
    
    - name: Update CHANGELOG.md
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        $version = "${{ steps.version.outputs.VERSION }}"
        $changelogPath = "CHANGELOG.md"
        $changelog = Get-Content $changelogPath -Raw
        
        $versionPattern = [regex]::Escape($version)
        if ($changelog -match "\[$versionPattern\]") {
          Write-Output "Version $version already in CHANGELOG.md"
          exit 0
        }
        
        $lastVersion = "${{ steps.last_version.outputs.LAST_VERSION }}"
        if ($lastVersion -eq "0.0.0") {
          $gitLog = git log --oneline --pretty="- %s" -- src/ Cargo.toml build.rs
        } else {
          $gitLog = git log "v$lastVersion..HEAD" --oneline --pretty="- %s" -- src/ Cargo.toml build.rs
        }
        
        $today = Get-Date -Format "yyyy-MM-dd"
        $newEntry = "## [$version] - $today`n`n### Changed`n$gitLog`n"
        
        $lines = $changelog -split "`n"
        $insertIndex = 0
        for ($i = 0; $i -lt $lines.Count; $i++) {
          if ($lines[$i] -match "^## \[") {
            $insertIndex = $i
            break
          }
        }
        
        $updatedChangelog = (($lines[0..($insertIndex - 1)] | Join-String -Separator "`n")) + "`n$newEntry" + (($lines[$insertIndex..($lines.Count - 1)] | Join-String -Separator "`n"))
        Set-Content $changelogPath $updatedChangelog -Encoding UTF8
        
        Write-Output "Updated CHANGELOG.md with version $version"
    
    - name: Commit changelog updates
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        if (git diff --quiet) {
          Write-Output "No changelog changes to commit"
        } else {
          git add CHANGELOG.md
          git commit -m "docs: update changelog for v${{ steps.version.outputs.VERSION }}"
          git push origin HEAD:main
        }
    
    - name: Build release binary
      run: cargo build --release
    
    - name: Capture build information
      id: build_info
      shell: pwsh
      run: |
        $binaryPath = Resolve-Path 'target/release/wincamcfg.exe'
        Write-Output "BINARY_PATH=$binaryPath" >> $env:GITHUB_OUTPUT
        Write-Output "Binary path: $binaryPath"
    
    - name: Install cargo-sbom
      run: cargo install cargo-sbom
    
    - name: Generate SBOM
      run: cargo sbom --output-format spdx-json > sbom.spdx.json
    
    - name: Capture SBOM information
      id: sbom_info
      shell: pwsh
      run: |
        $sbomPath = Resolve-Path 'sbom.spdx.json'
        Write-Output "SBOM_PATH=$sbomPath" >> $env:GITHUB_OUTPUT
        Write-Output "SBOM path: $sbomPath"
    
    - name: Generate artifact attestation
      uses: actions/attest-build-provenance@v1
      with:
        subject-path: 'target/release/wincamcfg.exe'
    
    - name: Generate SBOM attestation
      uses: actions/attest-sbom@v1
      with:
        subject-path: 'target/release/wincamcfg.exe'
        sbom-path: 'sbom.spdx.json'
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.VERSION }}
        draft: false
        prerelease: false
        files: |
          target/release/wincamcfg.exe
          sbom.spdx.json
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
